
use std::*;

pub struct Option<T> {
    value: T,
    exists: bool
}

impl<T> Option<T> {
    pub fn some(value: T) -> Option<T> {
        _ { value: value, exists: true }
    }

    pub fn none() -> Option<T> {
        _ { value: std::mem::new_uninit(), exists: false }
    }

    pub fn is_some(self: Option<T>) -> bool {
        self.exists
    }

    pub fn is_none(self: Option<T>) -> bool {
        self.exists == false
    }

    pub fn to_result(self: Option<T>, error: c_str) -> Result<T> {
        if self.exists {
            Result::<_>::ok(self.value)
        } else {
            Result::<_>::err(error)
        }
    }

    pub fn unwrap(self: Option<T>) -> T {
        if self.exists {
            self.value
        } else {
            c_api::fprintf(std::io::stderr, "ERROR: Unwrapping empty option\n");
            c_api::exit(1);
            unreachable()
        }
    }

    pub fn unwrap_or(self: Option<T>, fallback: T) -> T {
        if self.exists {
            self.value
        } else {
            fallback
        }
    }

    pub fn expect(self: Option<T>, error: c_str) -> T {
        if self.exists {
            self.value
        } else {
            c_api::fprintf(std::io::stderr, "ERROR: Unwrapping empty option: %s\n", error);
            c_api::exit(1);
            unreachable()
        }
    }

    pub fn replace(self: ptr<Option<T>>, new: T) -> Option<T> {
        if self.exists {
            Option::<_>::some(std::mem::replace(&self.value, new))
        } else {
            self.value = new;
            self.exists = true;
            Option::<_>::none()
        }
    }

    pub fn take(self: ptr<Option<T>>) -> T {
        if self.exists {
            self.exists = false;
            self.value
        } else {
            c_api::fprintf(std::io::stderr, "ERROR: Cannot take value out of empty option\n");
            c_api::exit(1);
            unreachable()
        }
    }

    pub fn try_take(self: ptr<Option<T>>) -> Option<T> {
        if self.exists {
            self.exists = false;
            Option::<_>::some(self.value)
        } else {
            self.exists = false;
            Option::<_>::none()
        }
    }

    pub fn as_ref(self: ptr<Option<T>>) -> Option<ptr<T>> {
        if self.exists {
            Option::<_>::some(&self.value)
        } else {
            Option::<_>::none()
        }
    }

    pub fn deref(self: Option<ptr<T>>) -> Option<T> {
        if self.exists {
            Option::<_>::some(*self.value)
        } else {
            Option::<_>::none()
        }
    }
}