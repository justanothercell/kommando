
use std::*;

pub struct Option<T> {
    item: T,
    exists: bool
}

impl<T> Option<T> {
    pub fn some(item: T) -> Option<T> {
        _ { item: item, exists: true }
    }

    pub fn none() -> Option<T> {
        _ { item: std::mem::new_uninit(), exists: false }
    }

    pub fn is_some(self: Option<T>) -> bool {
        self.exists
    }

    pub fn is_none(self: Option<T>) -> bool {
        self.exists == false
    }

    pub fn unwrap(self: Option<T>) -> T {
        if self.exists {
            self.item
        } else {
            c_api::printf("ERROR: Cannot unwrap empty option\n");
            c_api::exit(1);
            unreachable()
        }
    }

    pub fn unwrap_or(self: Option<T>, fallback: T) -> T {
        if self.exists {
            self.item
        } else {
            fallback
        }
    }

    pub fn replace(self: ptr<Option<T>>, new: T) -> Option<T> {
        if self.exists {
            Option::<_>::some(std::mem::replace(&self.item, new))
        } else {
            self.item = new;
            self.exists = true;
            Option::<_>::none()
        }
    }

    pub fn take(self: ptr<Option<T>>) -> T {
        if self.exists {
            self.exists = false;
            self.item
        } else {
            c_api::printf("ERROR: Cannot take item out of empty option\n");
            c_api::exit(1);
            unreachable()
        }
    }

    pub fn try_take(self: ptr<Option<T>>) -> Option<T> {
        if self.exists {
            self.exists = false;
            Option::<_>::some(self.item)
        } else {
            self.exists = false;
            Option::<_>::none()
        }
    }

    pub fn as_ref(self: ptr<Option<T>>) -> Option<ptr<T>> {
        if self.exists {
            Option::<_>::some(&self.item)
        } else {
            Option::<_>::none()
        }
    }

    pub fn as_deref(self: ptr<Option<ptr<T>>>) -> Option<T> {
        if self.exists {
            Option::<_>::some(*self.item)
        } else {
            Option::<_>::none()
        }
    }
}