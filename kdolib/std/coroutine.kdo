use std::*;
use io::stderr;

use core::drop::Drop;
use core::drop::Raw;

pub struct CoroContext<A, T> {
    main_ctx: c_api::ucontext::ucontext_t,
    runner_ctx: c_api::ucontext::ucontext_t,
    stack: raw_ptr,
    state: u8,
    function: function_ptr<T>,
    arg: Raw<A>,
    ret: Raw<T>,
}

impl<A, T> CoroContext<A, T> {
    pub fn yield(ctx: ptr<CoroContext<A, T>>, ret: T) -> A {
        ctx.ret.item = ret;
        if c_api::ucontext::swapcontext(&ctx.runner_ctx, &ctx.main_ctx) == 0-1 {
            panic("Coroutine: swapcontext failed")
        };
        std::mem::replace(&ctx.arg.item, std::mem::uninit())
    }
}

pub struct Coroutine<A, T> {
    // needs to be heaped so it doesnt move
    ctx: Box<CoroContext<A, T>>,
    state: i32
}

impl<A, T> Coroutine<A, T> {
    pub fn new(function: function_ptr<T>) -> Coroutine<A, T> {
        let stack_size: std::usize = 256 * 64;
        let stack = c_api::malloc(stack_size);
    
        let ctx: _<CoroContext<A, T>> = Box::<_>::new(_ {
            main_ctx: std::mem::uninit(),
            runner_ctx: std::mem::uninit(),
            stack: stack,
            state: 0,
            function: function,
            arg: std::mem::uninit(),
            ret: std::mem::uninit()
        });

        let ctx_ref = ctx.ref();
        ctx_ref.runner_ctx.uc_stack.ss_sp = stack;
        ctx_ref.runner_ctx.uc_stack.ss_size = stack_size;
        ctx_ref.runner_ctx.uc_link = (&ctx_ref.main_ctx);

        if c_api::ucontext::getcontext(&ctx_ref.runner_ctx) == 0-1 {
            panic("Coroutine: getcontext failed")
        };
    
        c_api::ucontext::makecontext(&ctx_ref.runner_ctx, coro_start::<A, T>, 2, ctx_ref);
    
        Coroutine {
            ctx: ctx,
            state: 0
        }
    }

    pub fn step(coro: ptr<Coroutine<A, T>>, arg: A) -> T {
        if coro.state != 0 {
            c_api::fprintf(io::stderr, "Error: coroutine cannot be stepped, is already done\n");
            c_api::exit(1);
        };
        let ctx = coro.ctx.ref();
        ctx.arg.item = arg;
        if c_api::ucontext::swapcontext(&ctx.main_ctx, &ctx.runner_ctx) == 0-1 {
            c_api::fprintf(io::stderr, "Error: swapcontext\n");
            c_api::exit(1);
        };
        if ctx.state == 1 {
            coro.state = 1;
        };
        std::mem::replace(&ctx.ret.item, std::mem::uninit())
    }
}

fn coro_start<A, T>(ctx: ptr<CoroContext<A, T>>) {
    ctx.ret.item = (ctx.function)(ctx, std::mem::replace(&ctx.arg.item, std::mem::uninit()));
    ctx.state = 1;
}

impl<A, T> CoroContext<A, T>: Drop {
    fn drop(self: ptr<CoroContext<A, T>>) {
        c_api::free(self.stack);
        // TODO: drop A and T
    }
}