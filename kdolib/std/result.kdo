use std::*;
use std::fmt::*;

use core::copy::Copy;
use core::clone::Clone;
use core::drop::Drop;
use core::drop::Raw;

pub struct Result<T, E> {
    value: Raw<T>,
    error: Raw<E>,
    is_ok: bool
}

impl<T, E> Result<T, E> {
    pub fn ok(value: T) -> Result<T, E> {
        _ { value: _ { item: value }, error: _ { item: std::mem::uninit() }, is_ok: true }
    }

    pub fn err(error: E) -> Result<T, E> {
        _ { value: _ { item: std::mem::uninit() }, error: _ { item: error }, is_ok: false }
    }

    pub fn is_ok(self: Result<T, E>) -> bool {
        self.is_ok
    }

    pub fn is_err(self: Result<T, E>) -> bool {
        self.is_ok == false
    }

    pub fn to_ok_option(self: Result<T, E>) -> Option<T> {
        if self.is_ok {
            Option::<_>::some(std::mem::replace(&self.value.item, std::mem::uninit()))
        } else {
            Option::<_>::none()
        }
    }

    pub fn to_err_option(self: Result<T, E>) -> Option<E> {
        if self.is_ok {
            Option::<_>::none()
        } else {
            Option::<_>::some(std::mem::replace(&self.error.item, std::mem::uninit()))
        }
    }

    pub fn unwrap_or(self: Result<T, E>, fallback: T) -> T {
        if self.is_ok {
            std::mem::replace(&self.value.item, std::mem::uninit())
        } else {
            fallback
        }
    }

    pub fn as_ref(self: ptr<Result<T, E>>) -> Result<ptr<T>, ptr<E>> {
        if self.is_ok {
            Result::<_, _>::ok(&self.value.item)
        } else {
            Result::<_, _>::err(&self.error.item)
        }
    }
}

impl<T, E: Fmt> Result<T, E> {
    pub fn unwrap(self: Result<T, E>) -> T {
        if self.is_ok {
            std::mem::replace(&self.value.item, std::mem::uninit())
        } else {
            panic(format("Unwrapping erroneous result $", self.error.item.dyn_fmt()))
        }
    }

    pub fn expect(self: Result<T, E>, error: c_str) -> T {
        if self.is_ok {
            std::mem::replace(&self.value.item, std::mem::uninit())
        } else {
            panic(format("Unwrapping erroneous result: $: $", error.dyn_fmt(), self.error.item.dyn_fmt()))
        }
    }
}

impl<T: Fmt, E: Fmt> Result<T, E>: Fmt {
    fn dyn_fmt(self: ptr<Result<T, E>>) -> DynFmt {
        _ { object: typecast(self), fmt: Result::<T, E>::fmt }
    }
    fn fmt(self: ptr<Result<T, E>>, fmt: ptr<Formatter>, stream: ptr<FormatStream>) {
        if self.is_ok {
            stream.write_str("some(").write(fmt, &self.value.item).write_str(")");
            stream.write_str(")");
        } else {
            stream.write_str("err(").write(fmt, &self.error.item).write_str(")");
        }
    }
}

impl<T: Copy, E: Copy> Result<T, E>: Copy {}

impl<T: Copy, E> Result<T, E> {
    pub fn deref(self: Result<ptr<T>, E>) -> Result<T, E> {
        if self.is_ok {
            Result::<_, _>::ok(*self.value.item)
        } else {
            Result::<_, _>::err(std::mem::replace(&self.error.item, std::mem::uninit()))
        }
    }
}

impl<T, E: Copy> Result<T, E> {
    pub fn err_deref(self: ptr<Result<T, ptr<E>>>) -> Result<T, E> {
        if self.is_ok {
            Result::<_, _>::ok(std::mem::replace(&self.value.item, std::mem::uninit()))
        } else {
            Result::<_, _>::err(*self.error.item)
        }
    }
}


impl<T: Clone, E: Clone> Result<T, E>: Clone {
    fn clone(self: ptr<Result<T, E>>) -> Result<T, E> {
        if self.is_ok {
            Result::<_, _>::ok(self.value.item.clone())
        } else {
            Result::<_, _>::err(self.error.item.clone())
        }
    }
}

impl<T: Drop, E: Drop> Result<T, E>: Drop {
    fn drop(self: ptr<Result<T, E>>) {
        if self.is_ok {
            self.value.item.drop();
        } else {
            self.error.item.drop();
        }
    }
}